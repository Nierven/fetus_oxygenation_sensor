<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SciChart.Drawing.DirectX</name>
    </assembly>
    <members>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11CompatibilityHelper">
            <summary>
            A helper class which can be used to detect if the Direct3D10 enhancements to SciChart can run on the current hardware &amp; operating system
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11CompatibilityHelper.IsSupportedOperatingSystem">
            <summary>
            Supported operating systems include Windows Vista, Windows 7, Windows 8, 8.1 and up. Windows XP, 2000, 2003 are not supported. 
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11CompatibilityHelper.HasDirectX10CapableGpu">
            <summary>
            Determines if the current GPU supports DirectX10 or later
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11CompatibilityHelper.SupportsDirectX10">
            <summary>
            Determines if the current hardware &amp; software configuration fully supports DirectX10 or later
            </summary>
        </member>
        <member name="E:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.RenderingFailed">
            <summary>
            Event raised when Rendering Fails 
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.#ctor(System.Windows.Controls.Image,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="!:Direct3D10Image"/> class.
            </summary>
            <param name="image">The image.</param>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.TargetWidth">
            <summary>
            The width of the Render Target in pixels
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.TargetHeight">
            <summary>
            The height of the Render Target in pixels
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.FillSource">
            <summary>
            Should be called to fill the WPF Image from the Direct3D Render Target at the end of drawing
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.FillSourceNoD3DImage">
            <summary>
            Should be called to fill the WPF Image from the Direct3D Render Target at the end of drawing
            </summary>
            <remarks>
            Alternative method for filling a WriteableBitmap with directx content, avoiding D3DImage (does not work over RDP due to bug in .NET4.0 implementation of D3DImage)
            </remarks>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.StartD3DIfNotStarted(System.Int32,System.Int32,System.EventHandler{SciChart.Drawing.DirectX.Context.D3D11.DXErrorEventArgs})">
            <summary>
            Starts DirectX with the specified width and height of the target
            </summary>        
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.AliasDx10Texture">
            <summary>
            Alias the DX10 texture as a DX9 texture.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Image.OnIsFrontBufferAvailableChanged(System.Object,System.Windows.DependencyPropertyChangedEventArgs)">
            <summary>
             this fires when the screen saver kicks in, the machine goes into sleep or hibernate
             and any other catastrophic losses of the d3d device from WPF's point of view
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Renderer.CreateDx9Device">
            <summary>
            Create a Direct3D9 device to use for creating the D3D9Image texture.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Renderer.WaitForGPU">
            <summary>
             this will block and wait until the gpu is finished, this is needed to fix flickering on some slow gpus, 
             where the d3dimage copy may happen before rendering is finished 
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11Renderer.GetMatrixMode">
            <summary>
             Gets the matrix used used
            </summary>
            <returns></returns>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface">
            <summary>
            Provides a <see cref="T:SciChart.Drawing.Common.RenderSurfaceBase"/> implementation that uses a DirectX 10 High Quality and High Speed raster, capable of rendering with sub-pixel accuracy. 
            This requires DirectX10 hardware or later to run. Newer GPUs will have superior performance. If performance issues occur, please use the <see cref="T:SciChart.Drawing.HighSpeedRasterizer.HighSpeedRenderSurface"/>
            </summary>
            <seealso cref="T:SciChart.Drawing.HighSpeedRasterizer.HighSpeedRenderSurface"/>
            <seealso cref="T:SciChart.Drawing.Common.RenderSurfaceBase"/>
            <seealso cref="T:SciChart.Drawing.Common.IRenderContext2D"/>
        </member>
        <member name="E:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.InitializationFailed">
            <summary>
            This event handler will fire if the direct x initialization fails
            </summary>
        </member>
        <member name="E:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.RenderingFailed">
            <summary>
            Event handler to be used when rendering fails..
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface"/> class.
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.UseAlternativeFillSource">
            <summary>
            When false (default), uses <see cref="T:System.Windows.Interop.D3DImage"/> for hardware accelerated texture sharing. 
            When true, uses software method to FillSource (avoiding use of D3DImage). This can help compatibility on certain systems
            </summary>       
            <example>
            To enable compatibility mode for SciChart3DSurface, set this property once, statically, in your application
            <code>        
            void Foo()
            {
               Direct3D11RenderSurface.UseAlternativeFillSource = true;
            }
            </code>
            </example>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.GraphicsAdapterIndex">
            <summary>
            Sets the Graphics Adapter Index to use for the <see cref="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface"/>. Defaults to 0. Use values other than 0 only in multi GPU computers
            </summary>       
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.EnableForceWaitForGPU">
            <summary>
            When false (default), no waiting for gpu
            when true , we force wait for the gpu to finsh rendering before invaldintng the final image or copying it 
            </summary>       
            <example>
            To enable compatibility mode for SciChart3DSurface, set this property once, statically, in your application
            <code>        
            void Foo()
            {
               Direct3D11RenderSurface.EnableForceWaitForGPU = true;
            }
            </code>
            </example>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.SupportsDirectX10">
            <summary>
            Gets a value indicating whether your current hardware supports DirectX10. THIS CALL IS DEFERRED TO Direct3D10CompatibilityHelper.SupportsDirectX10. Please check the property values and Intellisense documentation for Direct3D10CompatibilityHelper to see the reason why this failed
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.SciChart#Drawing#DirectX#Rendering#IDirectXRenderSurface#GetRenderContext">
            <summary>
            Creates an <see cref="T:SciChart.Drawing.Common.IRenderContext2D" /> instance to perform drawing operations. Note this is only valid for the current render pass
            </summary>
            <returns></returns>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.GetRenderContext">
            <summary>
            When overridden in a derived class, returns a RenderContext valid for the current render pass
            </summary>
            <returns></returns>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.SciChart#Drawing#DirectX#Rendering#IDirectXRenderSurface#ResetD3D11With(System.Boolean)">
            <summary>
            Resets the D3D Engine with the flag <param name="useAlternativeFillSource"> which determines whether we use the alternative software path for mixing DirectX content with WPF.
            This flag (when true) improves compatibility on some older graphics hardware, at the expense of performance</param>
            </summary>
            <param name="useAlternativeFillSource">This flag (when true) improves compatibility on some older graphics hardware, at the expense of performance</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.InitEngineAsync">
            <summary>
            Initializes the Direct3D11RenderSurface D3D Engine Asynchronously. The task returns True when the operation has completed, or faulted if an exception occurs
            </summary>
            <returns></returns>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.RecreateSurface">
            <summary>
            this is called when window is created or resized
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.AssertSupportsDirectX">
            <summary>
            Asserts the current hardware/software configuration supports DirectX. 
            
            Will throw a PlatformNotSupportedException if InitializationFailed is not handled, otherwise, raises the InitializationFailed event 
            </summary>
            <exception cref="T:System.PlatformNotSupportedException"></exception>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.OnRenderSurfaceBaseLoaded(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Called when the <see cref="T:SciChart.Drawing.Common.RenderSurfaceBase" /> is loaded into the visual tree
            </summary>
            <param name="sender">The sender.</param>
            <param name="e">The <see cref="T:System.Windows.RoutedEventArgs" /> instance containing the event data.</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface.DisposeUnmanagedResources">
            <summary>
            Derived classes may override this method to be notified when to dispose of unmanaged resources. Called when the
            <see cref="T:SciChart.Drawing.Common.RenderSurfaceBase" /> is disposed
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper">
            <summary>
            <para>A helper class to enable the Direct3D11RenderSurface </para>
            
            <para>Usage: &gt;SciChartSurface DirectXHelper.TryApplyDirectXRenderer="True"/&lt;</para>
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.TryApplyDirectXRendererProperty">
            <summary>Defines the TryApplyDirectXRenderer attached property</summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.SetTryApplyDirectXRenderer(SciChart.Charting.Visuals.SciChartSurface,System.Boolean)">
            <summary>
            Sets the TryApplyDirectXRenderer attached property. When true, tries to apply DirectX rendering to the <see cref="T:SciChart.Charting.Visuals.SciChartSurface"/>
            </summary>
            <param name="element">The element.</param>
            <param name="value">if set to <c>true</c> tries to apply DirectX rendering to the <see cref="T:SciChart.Charting.Visuals.SciChartSurface"/>.</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.GetTryApplyDirectXRenderer(SciChart.Charting.Visuals.SciChartSurface)">
            <summary>
            Sets the TryApplyDirectXRenderer attached property value
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.FallbackTypeProperty">
            <summary>Defines the FallbackType attached property</summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.SetFallbackType(System.Windows.DependencyObject,System.Type)">
            <summary>
            Sets the FallbackType attached property. This is the type of <see cref="T:SciChart.Drawing.Common.RenderSurfaceBase"/> which is created if DirectX is not available
            </summary>
            <param name="element">The element.</param>
            <param name="value">if set to <c>true</c> tries to apply DirectX rendering to the <see cref="T:SciChart.Charting.Visuals.SciChartSurface"/>.</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DirectXHelper.GetFallbackType(System.Windows.DependencyObject)">
            <summary>
            Sets the FallbackType attached property value
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.DXErrorEventArgs">
            <summary>
            Event args used by the <see cref="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface"/>
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.DXErrorEventArgs.Exception">
            <summary>
            Gets or sets the exception.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DxRenderContext.CreateTexture(System.Int32,System.Int32,SciChart.Drawing.Common.TextureFormats)">
            <summary>
            Creates the texture.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
            <param name="textureFormat">The texture format.</param>
            <returns></returns>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DxRenderContext.DrawTexture(SciChart.Drawing.Common.ITexture2D,System.Windows.Rect,SciChart.Drawing.Common.TextureFiltering)">
            <summary>
            Draws the texture.
            </summary>
            <param name="texture">The texture.</param>
            <param name="viewportRect">The viewport rect.</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.DxRenderContext.DrawHeightTextureContours(SciChart.Drawing.Common.ITexture2D,SciChart.Drawing.Common.ITexture2D,System.Windows.Rect,System.Windows.Media.Color,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draws contours for a height texture the texture.
            </summary>
            <param name="texture">The float texture.</param>
            <param name="viewportRect">The viewport rect.</param>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext">
            <summary>
            Defines the interface to a 3D RenderContext
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext.BeginScene">
            <summary>
            BeginScene, must be called at the start of every frame
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext.EndScene">
            <summary>
            EndScene, called at the end of every frame
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext.RenderColorTriangles(System.Collections.Generic.List{System.Windows.Point},System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.UInt32})">
            <summary>
            Render a series of triangles that enclose points by heights sent, and filled with the colors sent 
            </summary>
            <param name="points"></param> base 2 points fron eight heights will be extended
            <param name="heights"></param> height used to extente length perpendicular on the point, creating quads ( 2 trangles for each 2 points )
            <param name="colors"></param> color used to fill the quads
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext.RenderGammaSeriesFilledTriangles(System.Collections.Generic.List{System.Windows.Point},System.Collections.Generic.List{System.Windows.Point},System.Collections.Generic.List{System.UInt32})">
            <summary>
            Render gamma series, with calculated point on the other side of the gamma curve
            </summary>
            <param name="points"></param>
            <param name="gammaPoints"></param>
            <param name="colors"></param>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.RdpDetectionTimer">
            <summary>
            Provides a helper class that can be used to detect if Remote Desktop sessions is in use on the current PC
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Context.D3D11.RdpDetectionTimer.IsRemoteDesktop">
            <summary>
            Determines if the code is being run under Remote Desktop
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Context.D3D11.RenderBuffers.Direct3D11LinesRenderBuffer">
            <summary>
            a buffer that only draws line primitives, lines are simple x-y  vertices
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Context.D3D11.RenderBuffers.Direct3D11LinesRenderBuffer.MinDistanceSquaredForCulling">
            <summary>
            The minimum distance squared between two Vector2 to qualify it for drawing
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.RenderBuffers.Direct3D11PixelsRenderBuffer.GetVertexByteSize">
            <summary>
             2 floats, one integer
            </summary>
            <returns></returns>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Context.D3D11.RenderBuffers.Direct3D11RenderContextBuffer.End">
            <summary>
            render primitives from list,
            clears primitives list,
            disposes buffer writer stream,
            flushes D3D device
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Rendering.DxTexture2D.Width">
            <summary>
            Gets the width of the texture
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Rendering.DxTexture2D.Height">
            <summary>
            Gets the height of the texture
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Rendering.DxTexture2D.TextureFormat">
            <summary>
            Gets the texture format for this texture
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Rendering.DxTexture2D.SetData(System.Int32[])">
            <summary>
            Sets int[] pixel data on the Texture. Assumes <see cref="F:SciChart.Drawing.Common.TextureFormats.Bgra8" />
            </summary>
            <param name="colorData">The color data for pixels.</param>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Rendering.DxTexture2D.SetFloatData(System.Single[])">
            <summary>
            Sets float[] pixel data on the Texture. Assumes <see cref="F:SciChart.Drawing.Common.TextureFormats.Float" />
            </summary>
            <param name="colorData">The color data for pixels.</param>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Rendering.IDirectXRenderSurface">
            <summary>
            Defines the interface to a <see cref="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface"/>: a DirectX10/11 implementation of <see cref="T:SciChart.Drawing.Common.RenderSurfaceBase"/> that uses high-quality, sub-pixel, hardware accelerated drawing algorithms.
            </summary>
            <seealso cref="T:SciChart.Drawing.DirectX.Context.D3D11.Direct3D11RenderSurface"/>
            <seealso cref="T:SciChart.Drawing.HighQualityRasterizer.HighQualityRenderSurface"/>
            <seealso cref="T:SciChart.Drawing.HighSpeedRasterizer.HighSpeedRenderSurface"/>
            <seealso cref="T:SciChart.Drawing.Common.RenderSurfaceBase"/>
            <seealso cref="T:SciChart.Drawing.Common.IRenderContext2D"/>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Rendering.IDirectXRenderSurface.GetRenderContext">
            <summary>
            Creates an <see cref="T:SciChart.Drawing.DirectX.Context.D3D11.IDirectXRenderContext"/> instance to perform drawing operations. Note this is only valid for the current render pass
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Rendering.IDirectXRenderSurface.ResetD3D11With(System.Boolean)">
            <summary>
            Resets the D3D Engine with the flag <param name="useAlternativeFillSource"> which determines whether we use the alternative software path for mixing DirectX content with WPF. 
            This flag (when true) improves compatibility on some older graphics hardware, at the expense of performance</param>
            </summary>
            <param name="useAlternativeFillSource">This flag (when true) improves compatibility on some older graphics hardware, at the expense of performance</param>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Common.Disposer">
            <summary>
            Disposes a class if not disposed
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Common.Disposer.RemoveAndDispose``1(``0)">
            <summary>
            Dispose an object instance and set the reference to null
            </summary>
            <typeparam name="T">The type of object to dispose</typeparam>
            <param name="disposer">A reference to the instance for disposal</param>
            <remarks>This method hides any thrown exceptions that might occur during disposal of the object (by design)</remarks>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Data.DrawingConstantsForShaders">
            <summary>
            is used to send data to graphics card into constant buffer
            !!!!!!!!size has to be multiple of 16 bit
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Data.DrawingConstantsForShaders3D">
            <summary>
            is used to send data to graphics card into constant buffer
            !!!!!!!!size has to be multiple of 16 bit
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Drawables.RenderingTechniqueIndex2D">
            <summary>
            enumerates rendering techniques in Shaders2.fx file
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo">
            <summary>
            contains information for rendering a single primitive - line, polyline, rectangle, list of sprites
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.StartVertex">
            <summary>
            points to common shared dynamic buffer
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.VertexCount">
            <summary>
            count of vertices in shared buffer used by this primitive
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.DrawingConstantsForShaders">
            <summary>
            contains variables which are sent to shader like color, line thickness, screen size
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.ShaderResourceView">
            <summary>
            texture resource
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.HeightsMapResourceView">
            <summary>
            texture resource
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo.Pen">
            pen used in primitive 
            
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Drawables.RenderingTechniqueIndex3D">
            <summary>
            enumerates rendering techniques in Shaders2.fx file
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo3D">
            <summary>
            contains information for rendering a single primitive - line, polyline, rectangle, list of sprites
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo3D.StartVertex">
            <summary>
            points to common shared dynamic buffer
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo3D.VertexCount">
            <summary>
            count of vertices in shared buffer used by this primitive
            </summary>
        </member>
        <member name="F:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo3D.DrawingConstantsForShaders">
            <summary>
            contains variables which are sent to shader like color, line thickness, screen size
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Engine2D.Drawables.PrimitiveInfo3D.ShaderResourceView">
            <summary>
            texture resource
            </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Engine2D.Effects.ShaderManager">
            <summary>
            compiles Direct3D shaders from FX files in assembly resources
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SciChart.Drawing.DirectX.Engine2D.Tess.Geom.EdgeEval(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)" -->
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Geom.EdgeSign(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            Returns a number whose sign matches EdgeEval(u,v,w) but which
            is cheaper to evaluate. Returns &gt; 0, == 0 , or &lt; 0
            as v is above, on, or below the edge uw.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Geom.EdgeIntersect(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            Given edges (o1,d1) and (o2,d2), compute their point of intersection.
            The computed point is guaranteed to lie in the intersection of the
            bounding rectangles defined by each edge.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.MakeEdge">
            <summary>
            Creates one edge, two vertices and a loop (face).
            The loop consists of the two new half-edges.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.Splice(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
             <summary>
             Splice is the basic operation for changing the
             mesh connectivity and topology. It changes the mesh so that
             eOrg->Onext = OLD( eDst->Onext )
             eDst->Onext = OLD( eOrg->Onext )
             where OLD(...) means the value before the meshSplice operation.
            
             This can have two effects on the vertex structure:
             - if eOrg->Org != eDst->Org, the two vertices are merged together
             - if eOrg->Org == eDst->Org, the origin is split into two vertices
             In both cases, eDst->Org is changed and eOrg->Org is untouched.
            
             Similarly (and independently) for the face structure,
             - if eOrg->Lface == eDst->Lface, one loop is split into two
             - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
             In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
            
             Some special cases:
             If eDst == eOrg, the operation has no effect.
             If eDst == eOrg->Lnext, the new face will have a single edge.
             If eDst == eOrg->Lprev, the old face will have a single edge.
             If eDst == eOrg->Onext, the new vertex will have a single edge.
             If eDst == eOrg->Oprev, the old vertex will have a single edge.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.Delete(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Removes the edge eDel. There are several cases:
            if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
            eDel->Lface is deleted. Otherwise, we are splitting one loop into two;
            the newly created loop will contain eDel->Dst. If the deletion of eDel
            would create isolated vertices, those are deleted as well.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.AddEdgeVertex(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Creates a new edge such that eNew == eOrg.Lnext and eNew.Dst is a newly created vertex.
            eOrg and eNew will have the same left face.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.SplitEdge(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Splits eOrg into two edges eOrg and eNew such that eNew == eOrg.Lnext.
            The new vertex is eOrg.Dst == eNew.Org.
            eOrg and eNew will have the same left face.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.Connect(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
             <summary>
             Creates a new edge from eOrg->Dst to eDst->Org, and returns the corresponding half-edge eNew.
             If eOrg->Lface == eDst->Lface, this splits one loop into two,
             and the newly created loop is eNew->Lface. Otherwise, two disjoint
             loops are merged into one, and the loop eDst->Lface is destroyed.
            
             If (eOrg == eDst), the new face will have only two edges.
             If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
             If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Mesh.ZapFace(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face)">
            <summary>
            Destroys a face and removes it from the global face list. All edges of
            fZap will have a NULL pointer as their left face. Any edges which
            also have a NULL pointer as their right face are deleted entirely
            (along with any isolated vertices this produces).
            An entire mesh can be deleted by zapping its faces, one at a time,
            in any order. Zapped faces cannot be used in further mesh operations!
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.MakeEdge(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            MakeEdge creates a new pair of half-edges which form their own loop.
            No vertex or face structures are allocated, but these must be assigned
            before the current edge operation is completed.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Splice(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Splice( a, b ) is best described by the Guibas/Stolfi paper or the
            CS348a notes (see Mesh.cs). Basically it modifies the mesh so that
            a->Onext and b->Onext are exchanged. This can have various effects
            depending on whether a and b belong to different face or vertex rings.
            For more explanation see Mesh.Splice().
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.MakeVertex(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
            origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
            a place to insert the new vertex in the global vertex list. We insert
            the new vertex *before* vNext so that algorithms which walk the vertex
            list will not see the newly created vertices.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.MakeFace(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face)">
            <summary>
            MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
            face of all edges in the face loop to which eOrig belongs. "fNext" gives
            a place to insert the new face in the global face list. We insert
            the new face *before* fNext so that algorithms which walk the face
            list will not see the newly created faces.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.KillEdge(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
            and removes from the global edge list.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.KillVertex(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            KillVertex( vDel ) destroys a vertex and removes it from the global
            vertex list. It updates the vertex loop to point to a given new vertex.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.KillFace(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face)">
            <summary>
            KillFace( fDel ) destroys a face and removes it from the global face
            list. It updates the face loop to point to a given new face.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.EdgeLeq(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
             <summary>
             Both edges must be directed from right to left (this is the canonical
             direction for the upper edge of each region).
            
             The strategy is to evaluate a "t" value for each edge at the
             current sweep line position, given by tess->event. The calculations
             are designed to be very stable, but of course they are not perfect.
            
             Special case: if both edge destinations are at the sweep event,
             we sort the edges by slope (they would otherwise compare equally).
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.FixUpperEdge(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Replace an upper edge which needs fixing (see ConnectRightVertex).
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.AddRegionBelow(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Add a new active region to the sweep line, *somewhere* below "regAbove"
            (according to where the new edge belongs in the sweep-line dictionary).
            The upper edge of the new region will be "eNewUp".
            Winding number and "inside" flag are not updated.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.FinishRegion(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
            <summary>
            Delete a region from the sweep line. This happens when the upper
            and lower chains of a region meet (at a vertex on the sweep line).
            The "inside" flag is copied to the appropriate mesh face (we could
            not do this before -- since the structure of the mesh is always
            changing, this face may not have even existed until now).
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.FinishLeftRegions(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
            <summary>
            We are given a vertex with one or more left-going edges. All affected
            edges should be in the edge dictionary. Starting at regFirst->eUp,
            we walk down deleting all regions where both edges have the same
            origin vOrg. At the same time we copy the "inside" flag from the
            active region to the face, since at this point each face will belong
            to at most one region (this was not necessarily true until this point
            in the sweep). The walk stops at the region above regLast; if regLast
            is null we walk as far as possible. At the same time we relink the
            mesh if necessary, so that the ordering of edges around vOrg is the
            same as in the dictionary.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.AddRightEdges(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,System.Boolean)">
            <summary>
            Purpose: insert right-going edges into the edge dictionary, and update
            winding numbers and mesh connectivity appropriately. All right-going
            edges share a common origin vOrg. Edges are inserted CCW starting at
            eFirst; the last edge inserted is eLast.Oprev. If vOrg has any
            left-going edges already processed, then eTopLeft must be the edge
            such that an imaginary upward vertical segment from vOrg would be
            contained between eTopLeft.Oprev and eTopLeft; otherwise eTopLeft
            should be null.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.SpliceMergeVertices(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
            <summary>
            Two vertices with idential coordinates are combined into one.
            e1.Org is kept, while e2.Org is discarded.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.VertexWeights(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,System.Single@,System.Single@)">
            <summary>
            Find some weights which describe how the intersection vertex is
            a linear combination of "org" and "dest". Each of the two edges
            which generated "isect" is allocated 50% of the weight; each edge
            splits the weight between its org and dst according to the
            relative distance to "isect".
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.GetIntersectData(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            We've computed a new intersection point, now we need a "data" pointer
            from the user so that we can refer to this new vertex in the
            rendering callbacks.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.CheckForRightSplice(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
             <summary>
             Check the upper and lower edge of "regUp", to make sure that the
             eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
             origin is leftmost).
            
             The main purpose is to splice right-going edges with the same
             dest vertex and nearly identical slopes (ie. we can't distinguish
             the slopes numerically). However the splicing can also help us
             to recover from numerical errors. For example, suppose at one
             point we checked eUp and eLo, and decided that eUp->Org is barely
             above eLo. Then later, we split eLo into two edges (eg. from
             a splice operation like this one). This can change the result of
             our test so that now eUp->Org is incident to eLo, or barely below it.
             We must correct this condition to maintain the dictionary invariants.
            
             One possibility is to check these edges for intersection again
             (ie. CheckForIntersect). This is what we do if possible. However
             CheckForIntersect requires that tess->event lies between eUp and eLo,
             so that it has something to fall back on when the intersection
             calculation gives us an unusable answer. So, for those cases where
             we can't check for intersection, this routine fixes the problem
             by just splicing the offending vertex into the other edge.
             This is a guaranteed solution, no matter how degenerate things get.
             Basically this is a combinatorial solution to a numerical problem.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.CheckForLeftSplice(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
             <summary>
             Check the upper and lower edge of "regUp", to make sure that the
             eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
             destination is rightmost).
            
             Theoretically, this should always be true. However, splitting an edge
             into two pieces can change the results of previous tests. For example,
             suppose at one point we checked eUp and eLo, and decided that eUp->Dst
             is barely above eLo. Then later, we split eLo into two edges (eg. from
             a splice operation like this one). This can change the result of
             the test so that now eUp->Dst is incident to eLo, or barely below it.
             We must correct this condition to maintain the dictionary invariants
             (otherwise new edges might get inserted in the wrong place in the
             dictionary, and bad stuff will happen).
            
             We fix the problem by just splicing the offending vertex into the
             other edge.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.CheckForIntersect(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
             <summary>
             Check the upper and lower edges of the given region to see if
             they intersect. If so, create the intersection and add it
             to the data structures.
            
             Returns TRUE if adding the new intersection resulted in a recursive
             call to AddRightEdges(); in this case all "dirty" regions have been
             checked for intersections, and possibly regUp has been deleted.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.WalkDirtyRegions(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion)">
            <summary>
            When the upper or lower edge of any region changes, the region is
            marked "dirty". This routine walks through all the dirty regions
            and makes sure that the dictionary invariants are satisfied
            (see the comments at the beginning of this file). Of course
            new dirty regions can be created as we make changes to restore
            the invariants.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ConnectRightVertex(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Edge)">
             <summary>
             Purpose: connect a "right" vertex vEvent (one where all edges go left)
             to the unprocessed portion of the mesh. Since there are no right-going
             edges, two regions (one above vEvent and one below) are being merged
             into one. "regUp" is the upper of these two regions.
            
             There are two reasons for doing this (adding a right-going edge):
             - if the two regions being merged are "inside", we must add an edge
             to keep them separated (the combined region would not be monotone).
             - in any case, we must leave some record of vEvent in the dictionary,
             so that we can merge vEvent with features that we have not seen yet.
             For example, maybe there is a vertical edge which passes just to
             the right of vEvent; we would like to splice vEvent into this edge.
            
             However, we don't want to connect vEvent to just any vertex. We don''t
             want the new edge to cross any other edges; otherwise we will create
             intersection vertices even when the input data had no self-intersections.
             (This is a bad thing; if the user's input data has no intersections,
             we don't want to generate any false intersections ourselves.)
            
             Our eventual goal is to connect vEvent to the leftmost unprocessed
             vertex of the combined region (the union of regUp and regLo).
             But because of unseen vertices with all right-going edges, and also
             new vertices which may be created by edge intersections, we don''t
             know where that leftmost unprocessed vertex is. In the meantime, we
             connect vEvent to the closest vertex of either chain, and mark the region
             as "fixUpperEdge". This flag says to delete and reconnect this edge
             to the next processed vertex on the boundary of the combined region.
             Quite possibly the vertex we connected to will turn out to be the
             closest one, in which case we won''t need to make any changes.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ConnectLeftDegenerate(SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ActiveRegion,SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            The event vertex lies exacty on an already-processed edge or vertex.
            Adding the new vertex involves splicing it into the already-processed
            part of the mesh.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ConnectLeftVertex(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
             <summary>
             Purpose: connect a "left" vertex (one where both edges go right)
             to the processed portion of the mesh. Let R be the active region
             containing vEvent, and let U and L be the upper and lower edge
             chains of R. There are two possibilities:
            
             - the normal case: split R into two regions, by connecting vEvent to
             the rightmost vertex of U or L lying to the left of the sweep line
            
             - the degenerate case: if vEvent is close enough to U or L, we
             merge vEvent into that edge chain. The subcases are:
             - merging with the rightmost vertex of U or L
             - merging with the active edge of U or L
             - merging with an already-processed portion of U or L
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.SweepEvent(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Vertex)">
            <summary>
            Does everything necessary when the sweep line crosses a vertex.
            Updates the mesh and the edge dictionary.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.AddSentinel(System.Single,System.Single,System.Single)">
             <summary>
             Make the sentinel coordinates big enough that they will never be
             merged with real input features.
            
             We add two sentinel edges above and below all other edges,
             to avoid special cases at the top and bottom.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.InitEdgeDict">
            <summary>
            We maintain an ordering of edge intersections with the sweep line.
            This order is maintained in a dynamic dictionary.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.RemoveDegenerateEdges">
            <summary>
            Remove zero-length edges, and contours with fewer than 3 vertices.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.InitPriorityQ">
            <summary>
            Insert all vertices into the priority queue which determines the
            order in which vertices cross the sweep line.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.RemoveDegenerateFaces">
             <summary>
             Delete any degenerate faces with only two edges. WalkDirtyRegions()
             will catch almost all of these, but it won't catch degenerate faces
             produced by splice operations on already-processed edges.
             The two places this can happen are in FinishLeftRegions(), when
             we splice in a "temporary" edge produced by ConnectRightVertex(),
             and in CheckForLeftSplice(), where we splice already-processed
             edges to ensure that our dictionary invariants are not violated
             by numerical errors.
            
             In both these cases it is *very* dangerous to delete the offending
             edge at the time, since one of the routines further up the stack
             will sometimes be keeping a pointer to that edge.
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.ComputeInterior">
            <summary>
            ComputeInterior computes the planar arrangement specified
            by the given contours, and further subdivides this arrangement
            into regions. Each region is marked "inside" if it belongs
            to the polygon, according to the rule given by windingRule.
            Each interior region is guaranteed to be monotone.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.TessellateMonoRegion(SciChart.Drawing.DirectX.Engine2D.Tess.MeshUtils.Face)">
             <summary>
             TessellateMonoRegion( face ) tessellates a monotone region
             (what else would it do??) The region must consist of a single
             loop of half-edges (see mesh.h) oriented CCW. "Monotone" in this
             case means that any vertical line intersects the interior of the
             region in a single interval.
            
             Tessellation consists of adding interior edges (actually pairs of
             half-edges), to split the region into non-overlapping triangles.
            
             The basic idea is explained in Preparata and Shamos (which I don't
             have handy right now), although their implementation is more
             complicated than this one. The are two edge chains, an upper chain
             and a lower chain. We process all vertices from both chains in order,
             from right to left.
            
             The algorithm ensures that the following invariant holds after each
             vertex is processed: the untessellated region consists of two
             chains, where one chain (say the upper) is a single edge, and
             the other chain is concave. The left vertex of the single edge
             is always to the left of all vertices in the concave chain.
            
             Each step consists of adding the rightmost unprocessed vertex to one
             of the two chains, and forming a fan of triangles from the rightmost
             of two chain endpoints. Determining whether we can add each triangle
             to the fan is a simple orientation test. By making the fan as large
             as possible, we restore the invariant (check it yourself).
             </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.TessellateInterior">
            <summary>
            TessellateInterior( mesh ) tessellates each region of
            the mesh which is marked "inside" the polygon. Each such region
            must be monotone.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.DiscardExterior">
            <summary>
            DiscardExterior zaps (ie. sets to null) all faces
            which are not marked "inside" the polygon. Since further mesh operations
            on NULL faces are not allowed, the main purpose is to clean up the
            mesh so that exterior loops are not represented in the data structure.
            </summary>
        </member>
        <member name="M:SciChart.Drawing.DirectX.Engine2D.Tess.Tess.SetWindingNumber(System.Int32,System.Boolean)">
             <summary>
             SetWindingNumber( value, keepOnlyBoundary ) resets the
             winding numbers on all edges so that regions marked "inside" the
             polygon have a winding number of "value", and regions outside
             have a winding number of 0.
            
             If keepOnlyBoundary is TRUE, it also deletes all edges which do not
             separate an interior region from an exterior one.
             </summary>
        </member>
        <member name="T:SciChart.Drawing.DirectX.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:SciChart.Drawing.DirectX.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
    </members>
</doc>
